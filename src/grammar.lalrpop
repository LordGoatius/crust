use crate::parser::ast::*;
use std::str::FromStr;

grammar;

pub File: File = {
    <v:(<Decl> ";")*> => File(v),
}

Decl: Declaration = {
    CustomTypeDefinition => Declaration::TypeDefinition(<>),
    StaticVarDeclaration => Declaration::StaticVariableDeclaration(<>),
}

StaticVarDeclaration: StaticVariableDeclaration = {
    "static" <VarDecl> => StaticVariableDeclaration{ declaration: <> },
}

VarDecl: VariableDeclaration = {
    <var_type:Ty> <ident:Ident> <definition:("=" <TypeInstance>)?> => VariableDeclaration {
        var_type,
        ident,
        definition,
    },
}

TypeInstance: TypeInstantiation = {
    ArrayInstantiation => TypeInstantiation::Array(<>),
    TupleInstantiation => TypeInstantiation::Tuple(<>),
    StructInstantiation => TypeInstantiation::Struct(<>),
    EnumInstantiation => TypeInstantiation::Enum(<>),
    Expr => TypeInstantiation::Expr(<>),
}

// pub enum Expression {
//     // unary-op  = unop, ( ident | literal )
//     //           | unop, "(", expression, ")" ;
//     UnOp {
//         operation: UnOp,
//         operand: Box<Expression>
//     },
//     Ident(String),
//     // function-call = ident, "(", [ expression ], { ",", expression }, ")" ;
//     FunctionCall {
//         name: String,
//         arguments: Vec<Expression>
//     },
// }
Expr: Expression = {
    #[precedence(level="0")]
    Literal => Expression::Literal(<>),
    "(" <Expr> ")" => <>,
    <o:UnOp> <e:Expr> => Expression::UnOp {
        operation: o,
        operand: Box::new(e),
    },
    #[precedence(level="1")] #[assoc(side="left")]
    <e1:Expr> "." <e2:Expr> => Expression::BinOp {
        operation: BinOp::Access,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    #[precedence(level="2")] #[assoc(side="left")]
    <e1:Expr> "*" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Mul,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "/" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Div,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "%" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Mod,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "+" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Add,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "-" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Sub,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    #[precedence(level="4")] #[assoc(side="left")]
    <e1:Expr> "&" <e2:Expr> => Expression::BinOp {
        operation: BinOp::And,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "|" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Or,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "^" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Xor,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "&&" <e2:Expr> => Expression::BinOp {
        operation: BinOp::LogAnd,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "||" <e2:Expr> => Expression::BinOp {
        operation: BinOp::LogOr,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> ">>" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Shr,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "<<" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Shl,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> ">" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Gt,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "<" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Lt,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> ">=" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Geq,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "<=" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Leq,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "==" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Eq,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "!=" <e2:Expr> => Expression::BinOp {
        operation: BinOp::Neq,
        left: Box::new(e1),
        right: Box::new(e2),
    },
    <e1:Expr> "->"<e2:Expr> => Expression::BinOp {
        operation: BinOp::PtrAccess,
        left: Box::new(e1),
        right: Box::new(e2),
    },
}

UnOp: UnOp = {
    "*" => UnOp::Deref,
    "&" => UnOp::Ref,
    "++" => UnOp::Inc,
    "--" => UnOp::Dec,
    "~" => UnOp::Not,
    "!" => UnOp::LogNot,

}

// pub enum Literal {
//     Float {
//         num: f64
//     },
// } 
Literal: Literal = {
    r#""""# => Literal::String(String::new()),
    Number => Expression::Literal(Literal::Integer { sign: false, num: <> }),
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
}

EnumInstantiation: EnumInstantiation = {
    <s:Ident> <t:(":" <TypeInstance>)?> => EnumInstantiation {
        discriminator: s,
        value: t.map(|x| Box::new(x)),
    },
}

StructInstantiation: StructInstantiation = {
    "{" <fields:(<Ident> "=" <TypeInstance>)*> "}" => StructInstantiation {
        fields
    }
}

TupleInstantiation : TupleInstantiation = {
    "<" <n:TypeInstance> <v:(";" <TypeInstance>)+?> ">" => {
        match v {
            None => TupleInstantiation { values: vec![n] },
            Some(mut v) => {
                v.push(n);
                TupleInstantiation {
                    values: v                    
                }
            },
        }
    }
}

ArrayInstantiation: ArrayInstantiation = {
    "[" <n:TypeInstance> <v:("," <TypeInstance>)+?> "]" => {
        match v {
            None => ArrayInstantiation { values: vec![n] },
            Some(mut v) => {
                v.push(n);
                ArrayInstantiation {
                    values: v                    
                }
            },
        }
    }
}

CustomTypeDefinition: TypeDefinition = {
    "typedef" <ty:Ty> <alias:Ident> => TypeDefinition::TypeDef { old_type: Box::new(ty), alias },
    "struct" <ident:Ident> "{" <fields:InnerStruct> "}" => TypeDefinition::StructDef { ident, fields },
    "enum" <ident:Ident> "{" <values:InnerEnum> "}" => TypeDefinition::EnumDef { ident, values },
    "union" <ident:Ident> "{" <fields:InnerUnion> "}" => TypeDefinition::UnionDef { ident, fields },
}

// ( "union",  ident, "{", { ident, type-specifier, ";" }, "}" )
// { ident, type-specifier, ";" }
InnerStruct: Vec<(String, Type)> = {
    <v:(<Ident> <Ty> ";")*> => v,
}

// ( "enum",   ident, "{", { ident, type-specifier, "," }, "}" )
// { ident, type-specifier, ";" }
InnerUnion: Vec<(String, Type)> = {
    <v:(<Ident> <Ty> ";")*> => v,
}

InnerEnum: Vec<(String, Option<Type>)> = {
    <v:(<Ident> <ColonType?> ",")*> => v,
}

ColonType: Type = {
    ":" <Ty> => <>,
}

pub Ty: Type = {
    NonArrType => <>,
    "(" <v:TupleInner> ")" => Type::Tuple(v),
    <t:NonArrType> <a:ArrayDef> => Type::Array(Box::new(t), a),
    // Note: For Typedef
}

NonArrType: Type = {
    "u8" => Type::U8,
    "u16" => Type::U16,
    "u32" => Type::U32,
    "u64" => Type::U64,
    "usize" => Type::USize,
    "i8" => Type::I8,
    "i16" => Type::I16,
    "i32" => Type::I32,
    "i64" => Type::I64,
    "isize" => Type::ISize,
    "z8" => Type::Z8,
    "z16" => Type::Z16,
    "z32" => Type::Z32,
    "z64" => Type::Z64,
    "zsize" => Type::ZSize,
    "f32" => Type::F32,
    "f64" => Type::F64,
    "c32" => Type::C32,
    "c64" => Type::C64,
    "bool" => Type::Bool,
    "void" => Type::Void,
    "struct" <i:Ident> => Type::Struct(i),
    "enum" <i:Ident> => Type::Enum(i),
    "union" <i:Ident> => Type::Union(i),
    // Pointer may be moved and changed occasionally
    <t:NonArrType> "*" => Type::Pointer(Box::new(t)),
    Ident => Type::Ident(<>),
}

// array-def = type-specifier, [ "[", number, "]", ], { "[", number, "]", };
ArrayDef: Vec<usize> = {
    ("[" <Number> "]")+ => <>,
}

// ArraySize: Vec<usize> = {
//
// }

// tuple-def = [ type-specifier ], { ",", type-specifier }, ")", ";" ;
TupleInner: Vec<Type> = {
    <mut v:(<Ty> ",")*> <e:Ty?> => match e {
    None => v,
        Some(e) => { v.push(e); v }
    }
}

Ident: String = <s:r"[_a-zA-Z][_a-zA-Z0-9]*"> => s.to_owned();
// Fix Later Number: usize = <s:r"(?:(?:0b[01][01_]+)|(?:0o[0-7][0-7_]+)|(?:0x[0-9a-fA-F][0-9a-fA-F_]+)|(?:[0-9][0-9_]+))"> => s.parse().expect("Invalid integer literal");
pub Number: usize = <s:r"[0-9][0-9_]*"> => s.chars()
    .filter(|&c| char::is_numeric(c))
    .collect::<String>()
    .parse()
    .expect("Invalid integer literal");
